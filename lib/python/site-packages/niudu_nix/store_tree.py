import os
from PySide6.QtWidgets import QTreeView
from PySide6.QtCore import Qt, QItemSelection, QItemSelectionModel, QSignalBlocker
from PySide6.QtGui import QStandardItem, QStandardItemModel, QIcon, QPixmap, QFont
import subprocess
import pydenticon
import base64
import json


NIX_STORE_PATH_HASH_OFFSET = 11
NIX_STORE_PATH_HASH_LENGTH = 32
# Nix store path hash substr is actually non-standard base32 repr of 20bytes seq
NIX_STORE_PATH_HASH_BYTES = NIX_STORE_PATH_HASH_LENGTH*5//8
# lol Eelco chose custom baseN alphabet without few letters to avoid generation of offensive words, seems not to help much
ALPHABET_BASE32_RFC4648 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
ALPHABET_BASE32_EELCO =   '0123456789abcdfghijklmnpqrsvwxyz'
TRANSL_MAP_BASE32 = str.maketrans(ALPHABET_BASE32_EELCO, ALPHABET_BASE32_RFC4648)
PYDENTICON_SIZE_BLOCKS = 5
PYDENTICON_SIZE_PX = 20
# remainder of path after hash actually originates from val of "name" attr of derivation set in Nix scope
NIX_STORE_PATH_DERIVATION_NAME_OFFSET = NIX_STORE_PATH_HASH_OFFSET + NIX_STORE_PATH_HASH_LENGTH + 1


class FakeDigest:
    """
    Return hash passed to constructor, imitating parts of hashlib digest which are used by pydenticon
    """
    def __init__(self, val):
        self.val = val
    def hexdigest(self):
        # on pydenticon generator instantiation, it calls this for 'test' input and fails if digest is too short
        # it also stores test digest length and on subsequent calls treats data arg as hash if it's valid hex string of same length
        if self.val == b'test':
            return bytes(NIX_STORE_PATH_HASH_BYTES)
        else:
            return self.val


pydenticon_generator = pydenticon.Generator(PYDENTICON_SIZE_BLOCKS, PYDENTICON_SIZE_BLOCKS, digest=FakeDigest)


# custom selection model for treeview to prevent marking items selected on clicks and other events
# 'ignore' flag added to ignore all implicit calls while allowing explicit calls from own code
# clearSelection() also relies on calling select(), with QItemSelectionModel.Clear, therefore had to include it into condition
# note: Qt treeview "current item" and "selected items" are different things
# multiple items can be selected, only one can be current
# in Nix store paths dependency tree, store path on which multiple others depend appears multiple times
# we ensure that if item is selected, all other visible items with same store path are also selected, and only them
class StoreItemSelectionModel(QItemSelectionModel):
    def select(self, index_or_selection, flags, ignore=True):
        if not ignore or flags==QItemSelectionModel.Clear:
            super().select(index_or_selection, flags)


# Qt treeview displaying Nix store paths deps tree
class StoreTreeView(QTreeView):

    # TODO any issues from storing model and other stuff as fields to access without calling getters?
    def __init__(self, *args, **kwargs):
        self.status_bar = kwargs.pop('status_bar')
        super(StoreTreeView, self).__init__(*args, **kwargs)
        self.setModel(QStandardItemModel())
        self.setHeaderHidden(True)
        self.setSelectionModel(StoreItemSelectionModel(self.model()))
        self.setMouseTracking(True)
        self.expanded.connect(self.expanded__handler)
        self.entered.connect(lambda index: self.status_bar.showMessage(self.model().itemFromIndex(index).data()))
        self.selectionModel().currentChanged.connect(self.selection_model__current_changed__handler, Qt.QueuedConnection)
        # TODO
        self.highlighted_store_paths = [] #[path for path in get_system_pkgs_store_paths()]
        self.current_store_path = None

    # iterate subtree and select items with current store path
    # this non-recursive function iterates only through currently visible items (expanded)
    # it doesn't seem possible to iterate through all Qt tree model items non-recursively
    def select_items_in_subtree(self, root_index=None):
        item_selection = QItemSelection()
        current_index = self.indexBelow(root_index) if root_index is not None else self.model().index(0, 0)
        while current_index.isValid():
            if root_index is not None and current_index.parent() is root_index.parent():
                break
            if self.model().itemFromIndex(current_index).data() == self.current_store_path and not self.selectionModel().isSelected(current_index):
                item_selection.select(current_index, current_index)
            current_index = self.indexBelow(current_index)
        self.selectionModel().select(item_selection, QItemSelectionModel.Select, ignore=False)

    # on item expand, query its store path for dependencies and add them as its children
    # TODO cleanup upon item collapse?
    def expanded__handler(self, index):
        parent_item = self.model().itemFromIndex(index)
        if parent_item.rowCount() and not parent_item.child(0).data():
            parent_item.removeRow(0)
        else:
            # if current path was changed after subtree was collapsed, some of its children might have to be selected
            self.select_items_in_subtree(parent_item.index())
            return
        # load new items
        # select items with current store path
        child_paths = [child_path for child_path in iter_store_path_deps(parent_item.data())]
        child_paths.sort(key=lambda v: v[NIX_STORE_PATH_DERIVATION_NAME_OFFSET:])
        item_selection = QItemSelection()
        for child_path in child_paths:
            child_item = self.add_store_path(child_path, parent_item)
            # if store path is current store path, add item to selection
            if child_path == self.current_store_path:
                item_selection.select(child_item.index(), child_item.index())
        self.selectionModel().select(item_selection, QItemSelectionModel.Select, ignore=False)

    # insert item representing given Nix store path into treeview as child of provided parent
    def add_store_path(self, path, parent=None):
        if parent is None:
            parent = self.model().invisibleRootItem()
        store_icon_pixmap = QPixmap()
        # pydenticon is used here in such way that it considers data to be precalculated hash, see FakeDigest
        # we just need to convert nix store path hash to hex string
        # just for fun, let's accurately replicate output of nix-hash tool
        #hash_base16 = get_command_output('nix-hash --type sha1 --to-base16 '+path[11:11+32]).strip()
        hash_base32_eelco = path[NIX_STORE_PATH_HASH_OFFSET:NIX_STORE_PATH_HASH_OFFSET+NIX_STORE_PATH_HASH_LENGTH]
        hash_base32_rfc4648 = hash_base32_eelco.translate(TRANSL_MAP_BASE32)
        hash_ = base64.b32decode(hash_base32_rfc4648)[::-1] # nix-hash prints bytes in reversed order
        hash_base16 = base64.b16encode(hash_).decode()
        store_icon_pixmap.loadFromData(pydenticon_generator.generate(hash_base16, PYDENTICON_SIZE_PX, PYDENTICON_SIZE_PX))
        store_path_icon = QIcon(store_icon_pixmap)
        item = QStandardItem(store_path_icon, path[NIX_STORE_PATH_DERIVATION_NAME_OFFSET:])
        #item.setIcon(colorify_icon(item.icon(), None))
        item.setData(path)
        if path in self.highlighted_store_paths:
            font = QFont()
            font.setBold(True)
            item.setFont(font)
        parent.appendRow(item)
        # every item should have dummy child element to be expandable
        dummy_item = QStandardItem('')
        item.appendRow(dummy_item)
        return item

    # on current item change, if store path not same as previous, update current item info and selection
    def selection_model__current_changed__handler(self, current, previous):
        current_store_path = self.model().itemFromIndex(current).data()
        if current_store_path == self.current_store_path:
            return
        self.current_store_path = current_store_path
        self.derivation_view.update(self.current_store_path)
        self.contents_view.update(self.current_store_path)
        self.summary_view.update(self.current_store_path)
        self.selectionModel().clearSelection()
        # select items with current store path
        # only visible items are selected, items in collapsed subtrees are selected upon expanding
        self.select_items_in_subtree()


def iter_store_path_deps(path):
    command = 'nix-store --query --references ' + path
    process = subprocess.Popen(command.split(' '), stdout=subprocess.PIPE)
    (output, _) = process.communicate()
    _ = process.wait()
    for dep_path in output.decode().split('\n'):
        if dep_path and dep_path != path:
            yield dep_path

def get_command_output(command):
    process = subprocess.Popen(command.split(' '), stdout=subprocess.PIPE)
    (output, _) = process.communicate()
    _ = process.wait()
    return output

def iter_command_output_lines(command):
    for line in get_command_output(command).decode().split('\n'):
        if not line:
            break
        yield line

# get list of store paths which are produced by derivation sets listed in config.environment.systemPackages in Nix scope for highlighting
# these packages are roughly "installed software", see https://search.nixos.org/options?channel=unstable&show=environment.systemPackages
# however, list in scope is much larger than one in /etc/nixos/configuration.nix function output attr set attr environment.systemPackages
# /etc/nixos/configuration.nix function output is just input to other nixpkgs function which combines provided values with system defaults
# TODO this currently slows down startup, make it run in bg after tree is displayed, maybe via menu command, maybe more generic
# also this seems to only work correctly for system tree generated from current config
def get_system_pkgs_store_paths():
    print('getting store paths for packages listed in config.environment.systemPackages...')
    #command = "nix-instantiate --strict --eval -E 'builtins.map (p: p.outPath) (import <nixpkgs/nixos> {}).config.environment.systemPackages' --json"
    process = subprocess.Popen(["nix-instantiate", "--strict", "--eval", "-E", "builtins.map (p: p.outPath) (import <nixpkgs/nixos> {}).config.environment.systemPackages", "--json"], stdout=subprocess.PIPE)
    (output, _) = process.communicate()
    _ = process.wait()
    print('done')
    for path in json.loads(output):
        yield path
